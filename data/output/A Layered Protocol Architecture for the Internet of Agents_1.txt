 to work across multiple languages, both
natural and domain-specific.

Programming languages are themselves domain-specific lan-
guages, and compilers serve as DSL validators of both syntax and
semantics within the context of computation. LLMs excel at translat-
ing between languages—including from natural language to DSLs—
but lack inherent correctness guarantees. This observation reveals
a powerful synergy: if LLM agents can translate natural language
to DSL, and compilers can validate that DSL, then coupling natural
language with the syntax and semantics of DSLs bridges the gap
to distributed programming using agents. LLMs are exceptionally
strong at language transformation; external validation mechanisms
provide the correctness they lack.

Agent collaboration requires communication infrastructure that
goes beyond simple data exchange. When agents work together—
whether coordinating in supply chains, managing distributed sys-
tems, or solving multi-step reasoning tasks—they need to share
not just data but understanding. Current network stacks (OSI and
TCP/IP) were designed for reliable data delivery between processes,
not for semantic coordination between intelligent, autonomous en-
tities [13]. This gap has led to a proliferation of ad-hoc, application-
specific protocols that address agent communication in fragmented,
incompatible ways.

The "Internet of Agents" (IoA) emerges as the natural evolu-
tion: a communication infrastructure that enables agents to scale
through distributed computation and semantic coordination. How-
ever, efficient multi-agent systems require more than data exchange
protocols—they demand mechanisms that guarantee both computa-
tional efficiency and semantic correctness. The very capabilities that
make LLMs powerful—their fluency in natural language and ability
to handle ambiguity—create fundamental challenges for reliable
agent-to-agent communication.

The Protocol Challenge: Current protocols like A2A [1], MCP [5],

and FIPA-ACL standardize the syntax of agent messages—defining
envelopes, performatives, and interaction patterns—but cannot en-
force semantic agreement. They ensure messages are well-formed
but cannot guarantee that communicating agents share the same un-
derstanding of terms, concepts, or task parameters. This semantic

 
 
 
 
 
 
gap forces expensive disambiguation through iterative clarifica-
tion exchanges, undermining both computational efficiency and
deterministic behavior.

Consider two critical failure modes that arise from this syntactic-

only approach:

(1) Syntax Without Semantic Context: Syntax defines the
formal rules for constructing valid statements that can be parsed
by machines or interpreted by humans. Each language—whether
a programming language, domain-specific language (DSL), or nat-
ural language—has its own syntactic rules tailored to its purpose.
Formal languages excel at efficient syntax verification, enabling
computers to quickly validate statement structure and execute com-
putation deterministically. Natural languages, while syntactically
interpretable, are less efficient for computational execution due to
inherent ambiguity.

The critical insight for multi-agent systems is that we have de-
veloped numerous domain-specific languages transportable via
application-level protocols (JSON, XML, Protocol Buffers). LLM-
based agents can leverage these DSLs to generate syntactically
correct statements that execute efficiently. However, syntactic cor-
rectness alone is insufficient for reliable agent communication. A
term like "switch" can be syntactically valid in any language con-
text, yet its interpretation depends entirely on semantic context—
network device, electrical component, or strategic change. Current
protocols validate syntax but provide no mechanism to establish
which semantic context applies, forcing agents to guess or engage
in expensive clarification cycles.

(2) Semantic Underspecification: Even when syntax is perfect
and terms are unambiguous, messages can fail due to incomplete
semantic specification. Consider the syntactically valid request (RE-
QUEST :content "Book a ticket to New York"). The syntax is correct,
and "New York" is unambiguous as a proper noun. However, the
semantic context is severely underspecified: which New York en-
tity (city vs. state)? Which airport (JFK, LGA, EWR)? What travel
date? Which service class? Which passenger? These are not syntac-
tic ambiguities—the message parses correctly—but semantic gaps
where critical contextual parameters are missing.

Without a formal semantic layer that defines the required pa-
rameters for the "