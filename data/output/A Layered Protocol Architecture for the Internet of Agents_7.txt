 agent’s internal logic to the formal definitions
in the Shared Context. This function supports both transactional
and coordinative patterns, which map directly to the two dominant
paradigms in multi-agent systems today: agent orchestration and
agent collaboration. Transactional patterns enable orchestration,

where a central agent coordinates task execution across subordinate
agents (e.g., a travel agent orchestrating booking services). Coordi-
native patterns enable collaboration, where peer agents share state
and intentions to jointly solve problems without central control
(e.g., supply chain agents coordinating inventory decisions).
Example 1: Transactional Pattern (Booking a Flight)

• Context: ‘urn:contexts:travel:v2.1‘
• Schema Definition: Defines a task named ‘bookFlight‘
with required parameters ‘origin_code‘ (string), ‘dest_code‘
(string), and ‘date‘ (string, yyyy-mm-dd).

• Agent A Logic: "I need a flight to New York for next Tues-

day from LAX."

• Agent A (SNL) Grounding: The SNL processes this. It
successfully binds ‘origin_code: "LAX"‘ and ‘date: "2025-11-
04"‘. It finds ‘dest_code‘ is ambiguous ("New York").

• SNL-driven Clarification: The SNL does not send the
ambiguous prompt. It uses L8 to send a formal, L9-defined
query:

– L8 Performative: ‘QUERY‘
– L9 Content: ‘"concept": "ambiguous_parameter", "pa-

rameter": "dest_code", "value": "New York"‘

• Agent B (SNL) Response: Agent B’s SNL receives this, un-
derstands the ‘ambiguous_parameter‘ concept, and replies
via L8 ‘INFORM‘ with L9 ‘content‘: ‘"concept": "param-
eter_options", "parameter": "dest_code", "options": ["JFK",
"LGA", "EWR"]‘.

This clarification loop happens at the protocol level, deterministi-
cally, rather than as an ambiguous LLM "chat."

Example 2: Coordinative Pattern (Supply Chain Alignment)
In this way L9 supports complex, population-wide coordination
without needing to define a single "task."

• Context: ‘urn:contexts:supplyChain:v1.0‘
• Schema Definition: This schema does not define a "task."

Instead, it defines concepts that agents can share:

– Concept 1: ‘current_decision‘ (type: object, properties:

‘item_id‘, ‘quantity‘)

– Concept 2: ‘decision_contingency‘ (type: object, prop-

erties: ‘if_condition_text‘, ‘then_change_text‘)

– Concept 3: ‘local_observation‘ (type: object, proper-

ties: ‘observed_fact_text‘, ‘confidence_score‘)
• Agent A (Retailer) Logic: "My inventory is low. I’m or-
dering 120 units. It seems like a temporary demand spike.
If demand does increase 10%, I’ll increase my order by 15
units."

• Agent A (SNL) Grounding: The agent’s logic is passed
to its SNL. The SNL composes a semantically grounded L8
message to ‘PUBLISH‘ to its neighbors.

– L8 Performative: ‘INFORM‘
– L9 Content:

{

"my_decision": {

"concept_type": "current_decision",
"item_id": "beer",
"quantity": 120

},
"my_flexibility": {

"concept_type": "decision_contingency",
"if_condition_text": "demand increases by
10%",
"then_change_text": "increase order by
15 units"

},
"my_reasoning": {

"concept_type": "local_observation",

"observed_fact_text": "Current spike seems

temporary",
"confidence_score": 0.8

}

}

• Receiving Agent (SNL): Agent B (Wholesaler) receives
this L8 message. Its L9 SNL validates the ‘content‘ against
the locked ‘supplyChain:v1.0‘ context. It knows, at a proto-
col level, what ‘decision_contingency‘ is. It can now pass
this structured