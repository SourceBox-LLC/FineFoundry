 final outputs upon
completion. MCP similarly provides structured mechanisms for
agents to share context and invoke capabilities. Both protocols

excel at standardizing the syntactic envelope of communication—
defining message structure, performatives, and interaction patterns.
For example, a protocol might define a standard JSON structure

for agent messages:

JSON
{

"protocol": "A2A/1.0",
"performative": "REQUEST",
"sender_id": "agent-travel-7",
"receiver_id": "agent-booking-4",
"content": {

"task": "book_flight",

"prompt": "I need a flight to New York for next Tuesday."
}

}

This message is syntactically perfect. A protocol-aware agent can
parse it, identify the sender, and extract the task request. The proto-
col provides the flexible framework for communication. However,
the responsibility for specifying syntax and semantic context accu-
rately remains with the multi-agent system developer. The protocol
does not enforce or validate that both agents share the same un-
derstanding of what "book_flight" requires or what "New York"
means in this context. The receiving agent (agent-booking-4) has
no guaranteed, protocol-driven way to ground the natural language
string. Its LLM will be invoked on ambiguous data. The agent may:

• Guess: Assume "New York" means JFK and "next Tuesday"
means the immediate next Tuesday, potentially booking
the wrong flight.

• Clarify: Send a REQUEST-CLARIFY message back. This
results in a "prompt negotiation" loop, which is computa-
tionally expensive (each turn is a full LLM inference) and
non-deterministic.

• Fail: Reject the request as too ambiguous.

The core problem is this: Current protocols formalize the structure
of the request but not the context of the task. The most important
information—the shared understanding of terms, goals, and con-
straints—is left unmanaged, leading to brittle, unpredictable, and
inefficient multi-agent systems.

4 A Layered Architecture for the Agentic Web
To solve this impasse, we propose a new architectural stack. First,
we formally recognize HTTP/2 and HTTP/3 as Layer 7, the Appli-
cation Transport Layer, leveraging their FRAMES and STREAMS
capabilities as fundamental transport primitives. These protocols,
with their multiplexing, flow control, and efficient binary framing,
provide the ideal foundation for agent communication. We then
propose two new layers (L8 and L9) residing above the application
transport layer. This separation of concerns is critical for managing
the complexity of agentic communication.

4.1 Layer 8: The Agent Communication Layer
The first new layer, L8, is the Agent Communication Layer. Its
responsibility is to ensure that agents can reliably exchange struc-
tured messages, understand communicative intent, and coordinate
interaction flows—independently of semantic content. It unifies the

Traditional OSI

Application (L7)

Presentation (L6)

Session (L5)

Transport (L4)

Network (L3)

Data Link (L2)

Physical (L1)

Proposed Stack for Agents

Agentic
Application

Agentic Semantic
Negotiation

Agentic
Communication

App

App Transport
(L5-L7)

Transport (L4)

Network (L3)

Data Link (L2)

Physical (L1)

Figure 1: Traditional OSI stack and our proposed network
stack for agentic applications. We propose two new layers
for agent communication (L8 and L9) above HTTP/2/3, which
serves as the Application Transport layer (L7).

best parts of existing protocols (like A2A, MCP, NLIP, FIPA-ACL)
into a single, standardized layer that provides the syntactic and
protocol foundation for agent communication. The Agent Commu-
nication Layer is not concerned with what the data means, only
with ensuring messages are parseable, intentions are clear, and
interaction roles are well-defined.

To achieve this, L8 provides three essential components:

(1) Message Structure (The Envelope): Defines the standard
"envelope" for all agent messages, ensuring messages are
parseable and routable. Protocols like A2A